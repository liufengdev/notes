## 程序的机器级表示

“精通细节是理解更深和更基本概念的先决条件。”

- [C语言、汇编代码及机器代码之间的关系](#C语言、汇编代码及机器代码之间的关系)
- [数据的表示和处理](#数据的表示和处理)
- 如何实现C语言中的控制结构，如if/while和swift语句
- 过程的实现，如程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储
- 数组、结构和联合等数据结构的机器级实现
- 内存访问越界
- 缓冲区溢出攻击 
- lldb调试器检查机器级程序运行时行为(下一篇)

### C语言、汇编代码及机器代码之间的关系

调用以下命令将文件p1.c和p2.c转换为可执行代码
```
gcc -Og -o p p1.c p2.c
```
分为以下几步：

1. C`预处理器`扩展源代码，插入所有用 *#include* 命令指定的文件，并扩展所有用 *#define* 声明指定的宏
2. `编译器`产生两个源文件的汇编代码，名字分别为p1.s和p2.s
3. `汇编器`将汇编代码转换成二进制`目标代码`文件p1.o和p2.o
4. `链接器`将目标代码文件与实现库函数(例如printf)的代码合并，并产生最终的可执行代码文件p

#### x86_64的机器代码和原始C代码的区别

##### 部分处理器状态可见

- `程序计数器`(通常称为"PC"，在x86_64中用%rip表示)给出将要执行的下一条指令在内存中的地址
- `整数寄存器文件`包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(指针)或整数数据、记录程序状态、保存临时数据等
- `条件码`寄存器保存着最近执行的算术或逻辑指令的状态信息。主要用来实现控制或数据流中的条件变化，比如用来实现if和while语句
- *向量寄存器* 存放一个或多个整数或浮点数值

##### 内存模型

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块

- 机器代码将内存看做是很大的、按字节寻址的数据
- C语言中的聚合数据类型，如数组和结构体，在机器代码中用一组连续的字节来表示
- 对标量数据类型，汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数

##### 机器指令对应C程序结构

一条机器指令只执行一个非常基本的操作。为了实现程序结构（如表达式求值），编译器必须产生多个机器指令的序列

### 数据的表示和处理

#### 数据格式
大多数GCC生成的汇编代码指令多有一个字符的后缀，表明操作数的大小。如movb(传送字节)、movew
(传送字)、movl（传送双字 long word）和movq（传送四字）

#### 访问信息
对于生成小于8字节结果的指令，寄存器中剩下的字节处理规则：
1. 生成1字节和2字节数字的指令会保持剩下的字节不变；
2. 生成4字节数字的指令会把高位4字节置为0。(作为从32到x86_64扩展的一部分使用)

大多数指令有一个或多个`操作数`（operand），指示出要执行操作中的源数据以及放置结果的目的的
位置。不同的操作数可分为以下三种：
1. 立即数，用来表示常数值，如$-577或$0xF
2. 寄存器，表示寄存器的内容
3. 内存引用，根据计算出来的内存地址（`有效地址`）访问某个内存位置

##### 数据传送指令

MOV
把数据从源位置复制到目的位置，不做任何变化。包括movb、movw、movl和movq。
这些指令执行同样的操作，区别在于操作的数据大小不同：分别是1、2、4、8字节。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0（因为x86_64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分设置成0）

MOVZ
该类指令把目的中剩余的字节填充为0

MOVS
该类指令通过符合扩展来填充，把源操作的最高位进行复制

##### 压入和弹出栈数据

![栈操作](/images/csapp_stack_operation.png)

##### 算数和逻辑操作


  


